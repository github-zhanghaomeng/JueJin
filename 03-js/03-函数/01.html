<script>

    // 1.函数可以作为另一个函数的形参
    /*function  compute(f,x,y){
        return f(x,y);
    }
    console.log(compute(function add(a,b){return a+b;},1,2))
    */

    // 2.当函数没有写return语句时，函数调用时会返回undefined
    /*function f(){

    }
    console.log(f());
    */

    // 3.当函数遇到return语句时，return后面的与语句不会执行,return语句也叫跳转语句
    /*function f(){
        return 1;
        console.log(10);   不会显示10
    }
    console.log(f());
    */

    // 4.默认情况下，函数只能返回一个值
    /*function f(){
        return 1;
        return 2;
        return 3;
    }
    console.log(f());
    */

    // 5.如果相返回多个值，可以使用数组或者对象进行返回
    /*let a = [1,2,3];
    let b = {name:"wangcai",age:100};
    function f(){
        // return a   使用数组
        return b  使用对象
    }
    console.log(f())
    */

    // 6.实参就是给形参赋值，函数返回到函数调用处
    /*function add(x,y){
        return x+y;
    }
    console.log(add(1,2));  add(1,2)函数调用
    */

    // 7.实参不仅可以给形参赋值，还可以给arguments进行赋值，当实参有特殊含义时，需要有一个特殊的标识，就可以使用形参来标识
    /*function f(){
        return arguments
    }
    console.log(f(1,2,3,4,5))
    */

    // 8.当有多个实参时，可以使用arguments来完成功能
    /*let sum = 0;
    function add(){
        for(let i=0;i<arguments.length;i++){
            sum += arguments[i];
        }
        return sum;
    }
    console.log(add(1,2,3,4,5,6,7,8,9));
    */

    // 9.当改变形参值时，arguments的值也会改变
    /*function f(a){
        a = 8;
        return arguments;
    }
    console.log(f(7));
    */

    // 10.当改变arguments值时，形参的值也会改变  从9和10来看，说明形参和arguments是一一对应关系
    /*function f(a){
        arguments[0] = 10;
        return a;
    }
    console.log(f(5));
    */

    //11.计算函数运行的时间
    /*function computeTime(f) {
        let startTime = new Date().getTime(); // 开始时间
        f()
        let endTime = new Date().getTime(); // 开始时间
        let time = endTime - startTime;
        return time;
    }
    // f1叫实参
    console.log(computeTime(f1))

     function f1() {
        for (let i = 0; i < 100000; i++) {
            for (let i = 0; i < 10000; i++) {
            }
        }
    }
   */

    //12.定义器  3000毫秒  3s  3s之后，调用函数
   //setTimeout(function f(){console.log(123)},3000)

//    let a = [1];
//     function f(a){
//         a[100] = 3;
//         a = [1,2,3];
//         console.log(a);   //[1,2,3]
//     }
//     f(a);
//     console.log(a);       //[1,.........,3]



    // let a = [1];
    // function f(a){
    //     a[100] = 3;
    //     a = [4,5,6];
    //     console.log(a);
    // }
    // f(a);
    // console.log(a);
</script>

<script>
    /* var a = 110;
     console.log(a)
     console.log(b)  // b is not defined*/
</script>
<!-- 代码块 -->
<script>
    /* var b = 666;
     console.log(b)
     console.log(a)*/
</script>

<script>
    //  console.log(i)
    // //  循环  i叫循环变量  全局变量还是局部变量？ --->全局
    // for(var i = 1; i<=5; i++){
    //     console.log(i)
    // }

    // function f(){
    //     console.log(a)
    //     var a = 110;  // 提升到了函数内部最前面
    // }
    // // console.log(a)  // a is not defined
    // f();

    // console.log(a)
    // console.log(b)
    // // if else是一种二选一的结构 ()条件成立走第一个{}  条件不成立走else后面的{}
    // if(true){
    //     var a = 1;
    // }else{
    //     var b = 2;
    // }
    // console.log(a)
    // console.log(b)


    // let a = [5, 4, 3, 2, 1];
    // let minIndex;
    // let b;
    // for (let i = 0; i < a.length - 1; i++) {
    //     minIndex = i;
    //     for (let j = i + 1; j < a.length; j++) {
    //         if (a[j] < a[minIndex]) {
    //             minIndex = j;
    //         }
    //     }
    //     b = a[i];
    //     a[i] = a[minIndex];
    //     a[minIndex] = b;
    //     console.log(a);
    // }


    // let a = [5,4,3,2,1];
    // let b;
    // for(var i=1;i<=a.length-1;i++){
    //     for(var j=0;j<=a.length-1-i;j++){
    //         if(a[j]>a[j+1]){
    //             b = a[j+1];
    //             a[j+1] = a[j];
    //             a[j] =b;
    //         }
    //     }
    //     console.log(a);
    // }

//     function f(){
//         var a = 2;
//        function f1(){
//             console.log(a);
//         }
//         return f1;
//     }
//    console.log( f());
//     // f()();



</script>